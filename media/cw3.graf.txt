:doc title CSCI 2670 - Classwork 3

Name: Sai Anoop Avunuri

___ Instructions
> |> Create a \graf document with your answers to the following problems.  Save your work as a Grafstate file with the extension **{.graf.txt} and upload it to eLC.
> |> You may work in small groups.  List in your document *{all} of the students in your group.

:task By the end of this assignment, you should be able to convert a DFA to an @eqnt @regex using GNFAs.

___ Exercises
Convert the following DFA to an @eqnt @regex:
:+ dfa M
{
Q={q1,q2,q3,q4}
S={a,b}
q0=q1
d(q1,a)=q1
d(q1,b)=q3
d(q2,a)=q1
d(q2,b)=q4
d(q3,a)=q3
d(q3,b)=q2
d(q4,a)=q1
d(q4,b)=q4
F={q2,q3}
}

1. Create an initial GNFA G0 that is equivalent to M.

:+ gnfa G0
{
Q={qs,qf,q1,q2, q3, q4}
S={a,b}
q0=qs
F={qf}
qs->q1:\e
q1:a
q1->q3:b
q2->q1:a
q2->q4:b
q3:a
q3->q2:b
q4->q1:a
q4:b
q2->qf:\e
q3->qf:\e
}

2. Choose a state in Q.  Modify G0 to create an equivalent GNFA called G1 that contains all states in G0 except for the state you chose.

:+ gnfa G1
{
Q={qs,qf,q2, q3, q4}
S={a,b}
q0=qs
F={qf}
qs->q3:a*b
q2->q3:aa*b
q2->q4:b
q3:a
q3->q2:b
q4->q3:aa*b
q4:b
q2->qf:\e
q3->qf:\e
}

3. Choose another state in Q.  Modify G1 to create an equivalent GNFA called G2 that contains all states in G1 except for the state you chose.

:+ gnfa G2
{
Q={qs,qf, q3, q4}
S={a,b}
q0=qs
F={qf}
qs->q3:a*b
q3:a\ubaa*b
q3->q4:bb
q4->q3:aa*b
q4:b
q3->qf:\e \u b
}

4. Choose another state in Q.  Modify G2 to create an equivalent GNFA called G3 that contains all states in G2 except for the state you chose.

:+ gnfa G3
{
Q={qs,qf, q3}
S={a,b}
q0=qs
F={qf}
qs->q3:a*b
q3:a\ubaa*b\ubbb*aa*b
q3->qf:\e \u b
}

5. Choose another state in Q.  Modify G3 to create an equivalent GNFA called G4 that contains all states in G3 except for the state you chose.

:+ gnfa G4
{
Q={qs,qf}
S={a,b}
q0=qs
F={qf}
qs->qf:a*b(a\ubaa*b\ubbb*aa*b)*(\e \u b)
}

6. Choose a string of length 3 or greater that is accepted by M.  Explain how your string is matched by your @regex.
The string aba is accepted by M. This is matched by the @regex a*b(a)(\e) because the string begins with 1 a and has a b afterward and is followed by a and ends with \e.

:sim M aba